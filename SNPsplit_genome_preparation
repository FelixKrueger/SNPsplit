#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;
use FindBin qw($Bin);
use lib "$Bin/../lib";
use Cwd;

## This program is Copyright (C) 2014-16, Felix Krueger (felix.krueger@babraham.ac.uk)

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.


### This script filters the latest VCF file for various SNPs versus the GRCm38 mouse genome build and writes high confidence SNPs into a folder called 'SNPs_Sanger';
### It has been tested with the latest version of the SNP file 'mgp.v5.merged.snps_all.dbSNP142.vcf.gz' at the time of writing (11 May 2016). I can't guarantee that
### it will work with any other supplied VCF file.

## Reading in a BAM or SAM file
my $pipeline_version = '0.3.devel';
my $parent_dir = getcwd();
my ($vcf_file,$strain,$strain2,$strain_index,$strain2_index,$genome_folder,$skip_filtering,$nmasking,$full_sequence,$dual_hybrid) = process_commandline ();

warn "Summarising SNPsplit Genome Preparation Parameters\n";
warn "="x50,"\n";
warn "Processing SNPs from VCF file:\t\t $vcf_file\n";
if ($skip_filtering){
    warn "Reading/filtering VCF file:\t\tNo (skipped by user)\n";
}
else{
    warn "Reading/filtering VCF file:\t\tYes (default)\n";
}

warn "Reference genome:\t\t\t$genome_folder\n";
# N-masking
if ($nmasking){
    warn "N-masking:\t\t\t\tYes\n";
}
else{
    warn "N-masking:\t\t\t\tNo\n";
}

# Full SNP incorporation
if ($full_sequence){
    warn "Full SNP genome:\t\t\tYes\n";
}
else{
    warn "Full SNP genome:\t\t\tNo\n";
}
warn "SNP strain:\t\t\t\t$strain\n";
if ($strain2){
    warn "SNP strain 2:\t\t\t\t$strain2\n";
}
if ($dual_hybrid){
    warn "Dual hybrid, new Ref/SNP:\t\t$strain/$strain2\n";
}
warn "\n";

### Dealing with chromosomes
my @chroms = detect_chroms();
print "Using the following chromosomes (detected from VCF file >>$vcf_file<<):\n";
print join ("\t",@chroms),"\n\n";

### Determining and Filtering homozygous high-confidence SNPs for the strain in question
if ($skip_filtering){
    warn "Skipped reading the VCF file and filtering SNPs again (specified by user)\n\n";
}
else{
    filter_relevant_SNP_calls_from_VCF();
    warn "Finished filtering and writing out SNPs\n\n";
}


### Storing the entire genome sequence
my %chromosomes; # genomic sequence
read_genome_into_memory($parent_dir);

### Create modified genome

my $new_n_total = 0;
my $new_snp_total = 0;
my $already_total = 0;
my $low_confidence = 0;

# Writing a genome generation report file
my $report = "${strain}_genome_preparation_report.txt";
open (REPORT,'>',$report) or die "Failed to write to file $report: $!\n";

for my $chr (@chroms) {
    create_modified_chromosome($chr);
}

if ($nmasking){
    warn "\n\nSummary\n$new_n_total Ns were newly introduced into the N-masked genome in total\n";
    print REPORT "\nSummary\n$new_n_total Ns were newly introduced into the N-masked genome in total\n";
}

if ($full_sequence){
    warn "$new_snp_total SNPs were newly introduced into the full sequence genome version in total\n\n";
    print REPORT "$new_snp_total SNPs were newly introduced into the full sequence genome version in total\n";
}
warn "\n";

sub create_modified_chromosome {

    my ($chr) = @_;
    warn "Processing chr$chr (for strain $strain)\n";
    
    my $sequence = $chromosomes{$chr};
    my $n_sequence;
    
    if ($nmasking){
	$n_sequence = $sequence;
    }

    my @snps = @{read_snps($chr)};
    unless (@snps){
	@snps = ();
	warn "Clearing SNP array...\n"
    }
    
    my $count = 0;

    my $lastPos = 0;

    my $already = 0;
    my $warn = 0;
    my $new_n = 0;
    my $new_snp = 0;

    foreach my $snp (@snps) {
	# Apply the SNP
	++$count;
	# warn "$snp->[0]\t$snp->[1]/$snp->[2]\n";
	if ($snp->[0] == $lastPos) {
	    # Duplicate SNP
	    next;
	}
      
	$lastPos = $snp->[0];
	
	# Check if the reference base is the same as the SNP base
	if (substr ($sequence,$snp->[0]-1,1) eq $snp->[2]) {
	    # warn "Skipping $snp->[0] $snp->[1]/$snp->[2] since the ref and SNP base are the same\n";
	    ++$already;
	    next;
	}
      
	# Check the reference base is correct
	if (substr ($sequence,$snp->[0]-1,1) ne $snp->[1]) {
	    # warn "Skipping $snp->[0] $snp->[1]/$snp->[2] since the reference base didn't match\n";
	    $warn++;
	    next;
	}
      
	### Ref/Alt bases are matching, so we can proceed to changing the ref base for the SNP base or Ns (N-masking)
	
	### N-masking 
	if ($nmasking){ # default
	    my $return =  substr($n_sequence,($snp->[0])-1,1,'N');  # Replacing the base with 'N'
	    unless ($return){
		warn "Replacing failed...\n";
	    }
	    ++$new_n;
	}
	
	if ($full_sequence){
	    my $return = substr($sequence,$snp->[0]-1,1,$snp->[2]); # Replacing the reference with the SNP base
	    unless ($return){
		warn "Replacing failed...\n";
	    }
	    ++$new_snp;
	}
	
    }
  
    $new_n_total += $new_n;
    $new_snp_total += $new_snp;
    
    $already_total += $already;
    if ($nmasking){ 
	write_SNP_chromosome($chr,$n_sequence,1);
    }
    if ($full_sequence){
	write_SNP_chromosome($chr,$sequence,0);
    }
    
    warn "$count SNPs total for chromosome $chr\n";
    if ($nmasking){ # default
	warn "$new_n positions on chromosome $chr were changed to 'N'\n";
	print REPORT "$new_n positions on chromosome $chr were changed to 'N'\n";
    }
    if ($full_sequence){
	warn "$new_snp reference positions on chromosome $chr were changed to the SNP alternative base\n\n";
	print REPORT "$new_snp reference positions on chromosome $chr were changed to the SNP alternative base\n\n";
    }
    warn "\n";

}


sub write_SNP_chromosome {

    my ($chr,$sequence,$nm) = @_; # $nm will discriminate between N-masking and full sequence output
    if ($nm){
	warn "Writing modified chromosome (N-masking)\n";
    }
    else{
	warn "Writing modified chromosome (incorporating SNPs)\n";
    }
    
    my $type;
    my $outfile;
    
    if ($nm){
	$type = 'N-masked';
	$outfile = "chr${chr}.N-masked.fa";
    }
    if ($nm == 0){
	$type = 'full_sequence';
	$outfile = "chr${chr}.SNPs_introduced.fa";
    }
    
    # warn "Starting sequence is ".length($sequence)." bp\n";
    if ($nm){
	warn "Writing N-masked output to: ${parent_dir}/${strain}_${type}/$outfile\n";
	unless (-d "${parent_dir}/${strain}_${type}/"){ # creating the output directory if required
	    mkdir "${parent_dir}/${strain}_${type}/";
	}      
	open (OUT,'>',"${parent_dir}/${strain}_${type}/${outfile}") or die "Failed to write to file ${parent_dir}/${strain}_${type}/${outfile}: $!\n\n";
	print OUT ">$chr\n";
    }
    elsif ($nm == 0){
	warn "Writing full sequence output to: ${parent_dir}/${strain}_${type}/$outfile\n";
	unless (-d "${parent_dir}/${strain}_${type}/"){ # creating the output directory if required
	    mkdir "${parent_dir}/${strain}_${type}/";
	}      
 	open (OUT,'>',"${parent_dir}/${strain}_${type}/${outfile}") or die "Failed to write to file ${parent_dir}/${strain}_${type}/${outfile}: $!\n\n";
	print OUT ">$chr\n";
    }
    else{
	warn "Running out of options...\n\n";
    }
    
    my $pos = 0;

    # Writing out chromosome files with 100 characters per line
    while ($pos < length($sequence)-100) {
	print OUT substr($sequence,$pos,100),"\n";
	$pos += 100;
    }
    print OUT substr($sequence,$pos),"\n"; # rest
    close OUT or die $!;
   
}


sub read_snps {
    
    my ($chr) = @_;
    my @snps = ();
    my $file = "${parent_dir}/SNPs_${strain}/chr$chr.txt";

    ### If the SNP folder doesn't exist we can be certain that something is going wrong
    unless (-d "${parent_dir}/SNPs_${strain}"){
	die "Folder >>${parent_dir}/SNPs_${strain}<< doesn't exist. Try losing the option --skip_filtering to generate the folder and SNP files from the VCF file\n\n";
    }

    ### not sure but I think for some chromosomes there might not be any SNP files, e.g. chr MT or chrY. In this case the sequence is written out again unmodified
    unless (-e $file) {
	warn "Couldn't find SNP file for chromosome '$chr' '$file' didn't exist. Skipping...\n";
	return \@snps;
    }
    warn "Reading SNPs from file $file\n";
    
    open (IN,$file) or die $!;

    while (<IN>) {
	chomp;
	next unless ($_);
	
	my (undef,undef,$pos,$strand,$allele) = split(/\t/);
	next unless ($allele);
	
	my ($ref_allele,$snp_allele);

	if ($allele =~ /^([GATC])\/([GATC])$/) {
	    $ref_allele = $1;
	    $snp_allele = $2;
	}
	else {
	    warn "Skipping allele $allele\n";
	    next;
	}
	
	if ($strand == -1) { # if the strand is given as -1 it means that the SNP is on the reverse strand and thus needs reverse-coplementing
	    $ref_allele =~ tr/GATC/CTAG/;
	    $snp_allele =~ tr/GATC/CTAG/;
	}
	
	push @snps,[$pos,$ref_allele,$snp_allele];
    }

    # sorting snps
    @snps = sort {$a->[0] <=> $b->[0]} @snps;
    
    return \@snps;
    
    close IN or warn "Failed to close filehandle IN for file $file: $!\n\n";

}





###

sub filter_relevant_SNP_calls_from_VCF{
    
    if ($vcf_file =~ /gz$/){
	open (IN,"gunzip -c $vcf_file |") or die "Failed to open file '$vcf_file': $!\n";
    } 
    else{
	open (IN, $vcf_file) or die "Failed to read Input VCF file '$vcf_file': $!\n";
    }
    
    my $count = 0;

    my $other = 0;
    my $too_many = 0;
    
    my %fhs;
    my $hcg_count = 0;
    my $low_confidence = 0;
    my $same = 0;
    my $homozygous = 0;
    my %all_SNPs;
    

  
    my $dir = "SNPs_$strain";
    unless (-d $dir){
	warn "Folder '$dir' doesn't exist. Creating it for you...\n\n";
	mkdir $dir or die "Failed to created directory $dir\n: $!\n\n";
    }
    
    # Opening filehandles for the SNP files
    for my $chr (@chroms) {
	my $filename = "SNPs_$strain/chr".$chr.'.txt';
	open (my $fh,'>',$filename) or die "Couldn't open filehandle $!\n";
	$fhs{$chr} = $fh;
	print {$fhs{$chr}} ">$chr\n";
    }
    
    while (<IN>){
	$_ =~ s/(\r|\n)//g; # removing end of line characters

	# warn "$_\n"; sleep(1);
	next if ($_ =~ /^\#\#/); # filters out header information lines
	if ($_ =~ /^\#CHROM/){ # Table Header
	    my ($name) = (split /\t/)[$strain_index];
	    warn "Analysing SNP fields for name >$name<\n";
	    next;	
	}
	$count++;
	if ($count%1000000 ==0){
	    warn "processed $count lines\n";
	}
	# last if ($count == 1000);
	
	my ($chr,$pos,$ref,$alt,$strain) = (split /\t/)[0,1,3,4,$strain_index];
	# warn "$chr , $pos , $ref , $alt , $strain\n"; sleep(1);
	
	# $strain is in the form: GT:GQ:DP:MQ0F:GP:PL:AN:MQ:DV:DP4:SP:SGB:PV4:FI
	my ($gt,$gq,$dp,$mq0f,$gp,$pl,$an,$mq,$dv,$dp4,$sp,$sgb,$pv4,$fi) = split/:/,$strain;
	
	
	unless ($fi){
	    # warn "genotype: $gt\nfilter:   $fi\n\n";
	}

	# warn "genotype: $gt\nfilter:   $fi\n\n";
	# warn "$fi\n"; sleep(1);
	# $gt is the Genotype:
	
	# '.'   = no genotype call was made
	# '0/0' = genotype is the same as the reference genome
	# '1/1' = homozygous alternative allele; can also be '2/2',
	# '3/3', etc. if more than one alternative allele is present.
	# '0/1' = heterozygous genotype; can also be '1/2', '0/2', etc.
	
	# $fi is filter, 1 for high confidence SNP, or 0 for low confidence
	
	### We are only looking for 1/1 calls, and filter for high confidence as well
	
	# skipping if the reference base is not well defined in Black6
	if ($ref =~ /[^ATCG]/){ # reference base contained any non A, C, T, G characters or more than one base
	    warn "ref was: $ref; skipping\n";
	    next;
	}
	
	# skipping if the SNP is not well defined in the strain of interest
	if ($alt =~ /[^ATCG]/){ # Alt base contained any non A, C, T, G characters or more than one base
	    # warn "SNP was: $alt; skipping\n";
	    ++$too_many;
	    next;
	}
	
	# Filtering for genotype
	if ($gt eq '0/0'){
	    ++$same;
	    # warn "same as reference\n";
	    next;
	}
	elsif ($gt eq '1/1'){
	    ++$homozygous;
	    # warn "homozygous alternative allele\n";
	}
	else{
	    ++$other;
	    next;
	}
	
	# Looking at the Filtering tag
	# warn "$fi\n"; sleep(1);
	if ($fi == 1){
	    ++$hcg_count;
	    
	    my $location = join (':',$chr,$pos);
	    # warn "$location\n";
	    my $SNP = join ("\t",$count,$chr,$pos,'1',join ("\/",$ref,$alt));
	    # field 4: 1 means top strand, -1 means reverse strand
	    # warn "$SNP\n";sleep(1);
	    
	    if (exists $all_SNPs{$location} ){
		# warn "SNP $all_SNPs{$location} position was present already\n";
	    }
	    else{
		$all_SNPs{$location} = $SNP;
	    }
	}
	else{
	    ++$low_confidence;
	    next;
	}
	
	# Output example
	# Variation ID    Chromosome name Position on Chromosome (bp)     Strand  Allele
	# rs2020560       10      98212004        1       A/T
	
	print {$fhs{$chr}} join ("\t",$count,$chr,$pos,'1',join ("\/",$ref,$alt),$strain),"\n";
	
    }
    
    # Writing a report file
    my $report = "${strain}_SNP_filtering_report.txt";
    open (REPORT,'>',$report) or die "Failed to write to file $report: $!\n";
    
    warn "SNP position summary for strain $strain (based on mouse genome build GRCm38)\n";
    warn "="x80,"\n\n";
    warn "Positions read in total:\t$count\n\n";
    warn "$homozygous\tSNP were homozygous. Of these:\n";
    warn "$hcg_count\tSNP were homozygous and passed high confidence filters and were thus included into the $strain genome\n";
    warn "\nNot included into $strain genome:\n";
    warn "$same\thad the same sequence as the reference\n";
    warn "$too_many\t\thad no clearly defined alternative base\n";
    warn "$other\t\tCalls were neither 0/0 (same as reference) or 1/1 (homozygous SNP)\n";
    warn "$low_confidence\t\twere homozygous but the filtering call was low confidence\n\n";

    print REPORT "SNP position summary for strain $strain (based on mouse genome build GRCm38)\n";
    print REPORT "="x80,"\n\n";
    print REPORT "Positions read in total:\t$count\n\n";
    print REPORT "$homozygous\tSNP were homozygous. Of these:\n";
    print REPORT "$hcg_count\tSNP were homozygous and passed high confidence filters and were thus included into the $strain genome\n";
    print REPORT "\nNot included into $strain genome:\n";
    print REPORT "$same\thad the same sequence as the reference\n";
    print REPORT "$too_many\t\thad no clearly defined alternative base\n";
    print REPORT "$other\t\tCalls were neither 0/0 (same as reference) or 1/1 (homozygous SNP)\n";
    print REPORT "$low_confidence\t\twere homozygous but the filtering call was low confidence\n\n";
    
    close (REPORT) or warn "Failed to close filehandle REPORT\n";

    # Also writing all SNP calls out to an all-SNP file
    warn "Now printing a single list of all SNPs\n\n";
    my $all_SNPs = "all_SNPs_${strain}_GRCm38.txt.gz";
    if (-e $all_SNPs){
	warn "File '$all_SNPs' existed in the folder already, overwriting it...\n\n";
    }
    open (ALLSNP,"| gzip -c - > $all_SNPs") or die "Failed to write to file $all_SNPs: $!\n";
    
    foreach my $location (keys %all_SNPs){
	print ALLSNP "$all_SNPs{$location}\n";
    }
        
}

### SUBROUTINES


sub detect_chroms{

    my %chrom; # detecting the chromosomes from the VCF file
    my @chrom;

    if ($vcf_file =~ /gz$/){
	open (DETECT,"gunzip -c $vcf_file |") or die "Failed to open file '$vcf_file': $!\n";
    }
    else{
	open (DETECT, $vcf_file) or die "Failed to read Input VCF file '$vcf_file': $!\n";
    }
    
    # warn "Detecting chromosomes from file '$vcf_file'\n\n";
    while (<DETECT>){
	$_ =~ s/(\r|\n)//g; # removing end of line characters
	last unless ($_ =~ /^\#/);
	
	if ($_ =~ /^\#\#contig/){ # filters header lines
	    # warn "$_\n"; # sleep(1);
	    $_ =~ /ID=(.+),/;
	    my $chr = $1;
	    # warn "Identified chromosome $chr\n";
	    unless (exists $chrom{$chr}){
		$chrom{$chr}++;
	    }
	}
    }

    foreach my $chr(keys %chrom){
	# warn "$chr\n";	
	push @chrom, $chr;
    }
    # close DETECT or warn "Failed to close filehandle DETECT: $!\n";
    return @chrom;
    
}

sub detect_strains{
    
    my $vcf_file = shift;
    my %strains; # detecting the available strains from the VCF file
    
    if ($vcf_file =~ /gz$/){
	open (STRAIN,"gunzip -c $vcf_file |") or die "Failed to open file '$vcf_file': $!\n";
    }
    else{
	open (STRAIN, $vcf_file) or die "Failed to read Input VCF file '$vcf_file': $!\n";
    }
    
    # warn "Detecting strains from file '$vcf_file'\n\n";
    while (<STRAIN>){
	$_ =~ s/(\r|\n)//g; # removing end of line characters
	next if ($_ =~ /^\#\#/);	
	if ($_ =~ /^\#CHROM/){ # header line listing all different strains
	    # warn "$_\n"; sleep(1);
	}
	last unless ($_ =~ /^\#/); # everything from now on are the SNPs themselves
	
	my @strains = split (/\t/);
	
	foreach my $index(0..$#strains){
	    next if ($index <= 8); # The first 6 fields are irrelevant: #CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  
	    $strains{$strains[$index]} = $index; 
	    # warn "$index\t$strains[$index]\n";
	}
    }
    
    # close STRAIN or warn "Failed to close filehandle STRAIN: $!\n";
    return %strains;

}

sub read_genome_into_memory{
    
    ## working directoy
    my $cwd = shift;
    
    ## reading in and storing the specified genome in the %chromosomes hash
    chdir ($genome_folder) or die "Can't move to $genome_folder: $!";
    warn "Now reading in and storing sequence information of the genome specified in: $genome_folder\n\n";

    my @chromosome_filenames =  <*.fa>;

    ### if there aren't any genomic files with the extension .fa we will look for files with the extension .fasta
    unless (@chromosome_filenames){
      @chromosome_filenames =  <*.fasta>;
    }

    unless (@chromosome_filenames){
      die "The specified genome folder $genome_folder does not contain any sequence files in FastA format (with .fa or .fasta file extensions)\n";
    }

    my $SQ_count = 0;

    foreach my $chromosome_filename (@chromosome_filenames){

	open (CHR_IN,$chromosome_filename) or die "Failed to read from sequence file $chromosome_filename $!\n";
	### first line needs to be a fastA header
	my $first_line = <CHR_IN>;
	chomp $first_line;
	$first_line =~ s/\r//;
	### Extracting chromosome name from the FastA header
	my $chromosome_name = extract_chromosome_name($first_line);
	my $sequence;

	while (<CHR_IN>){
	  chomp;
	  $_ =~ s/\r//; # removing carriage returns if present
	  if ($_ =~ /^>/){
	
	    ### storing the previous chromosome in the %chromosomes hash, only relevant for Multi-Fasta-Files (MFA)
	    if (exists $chromosomes{$chromosome_name}){
	      print "chr $chromosome_name (",length $sequence ," bp)\n";
	      die "Exiting because chromosome name already exists. Please make sure all chromosomes have a unique name!\n";
	    }
	    else {
	      if (length($sequence) == 0){
		warn "Chromosome $chromosome_name in the multi-fasta file $chromosome_filename did not contain any sequence information!\n";
	      }
	      print "chr $chromosome_name (",length $sequence ," bp)\n";
	      $chromosomes{$chromosome_name} = $sequence;
	    }
	    ### resetting the sequence variable
	    $sequence = '';
	    ### setting new chromosome name
	    $chromosome_name = extract_chromosome_name($_);
	  }
	  else{
	    $sequence .= uc$_;
	  }
	}
	
 	### Processing last chromosome of a multi Fasta File or the only entry in case of single entry FastA files

	if (exists $chromosomes{$chromosome_name}){
	    print "chr $chromosome_name (",length $sequence ," bp)\t";
	    die "Exiting because chromosome name already exists. Please make sure all chromosomes have a unique name.\n";
	}
	else{
	    if (length($sequence) == 0){
		warn "Chromosome $chromosome_name in the file $chromosome_filename did not contain any sequence information!\n";
	    }

	    print "chr $chromosome_name (",length $sequence ," bp)\n";
	    $chromosomes{$chromosome_name} = $sequence;
	}
    }
    print "\n";
    chdir $cwd or die "Failed to move to directory $cwd\n";

}

sub extract_chromosome_name {
    ## Bowtie seems to extract the first string after the inition > in the FASTA file, so we are doing this as well
    my $fasta_header = shift;
    if ($fasta_header =~ s/^>//){
	my ($chromosome_name) = split (/\s+/,$fasta_header);
	return $chromosome_name;
    }
    else{
	die "The specified chromosome ($fasta_header) file doesn't seem to be in FASTA format as required!\n";
    }
}


###################################################################


sub process_commandline{
    my $help;
    my $version;
    my $vcf_file;
    my $strain;
    my $strain2;
    my $list_strains;
    my $skip_filtering;
    my $full_sequence;
    my $genome_folder;
    my $nmasking;
    my $dual_hybrid;
    my $no_nmasking;
    
    my $command_line = GetOptions ('help|man'             => \$help,
				   'versions'             => \$version,
				   'strain=s'             => \$strain, 
				   'strain2=s'            => \$strain2,
				   'list_strains'         => \$list_strains,
				   'skip_filtering'       => \$skip_filtering,
				   'vcf_file=s'           => \$vcf_file,
				   'full_sequence'        => \$full_sequence,
				   'nmasking'             => \$nmasking,
				   'no_nmasking'          => \$no_nmasking,
				   'dual_hybrid'          => \$dual_hybrid,
				   'reference_genome=s'   => \$genome_folder,
	);
  
    ### EXIT ON ERROR if there were errors with any of the supplied options
    unless ($command_line){
	die "Please respecify command line options\n";
    }
    
    ### HELPFILE
    if ($help){
	print_helpfile();
	exit;
    }
    
    if ($version){
	print << "VERSION";
	
                               SNPsplit Genome Preparation
				 version: $pipeline_version
                 Copyright 2014-16 Felix Krueger, Babraham Bioinformatics


VERSION
		 ;
   	exit;
    }

    if (defined $vcf_file){
	unless(-e $vcf_file){
	    die "Input VCF file '$vcf_file' doesn't exist in the folder. Please check filenames and try again!\n\n";
	}
    }
    else{
	die "\nYou need to provide a VCF file detailing SNPs positions with '--vcf_file your.file' (e.g.: --vcf mgp.v5.merged.snps_all.dbSNP142.vcf.gz). Please respecify!\n\n";
    }

    my %strains = detect_strains($vcf_file);

    if ($list_strains){
	warn "\nAvailable genomes to choose from are:\n";
	warn "="x37,"\n";
	foreach my $strain(keys %strains){
	    print "$strain\n";
	}
	warn "="x37,"\n";
	warn "\nPlease choose a strain using '--strain NAME' to continue.\n\n";
	exit;
    }

    my $strain_index;
    my $strain2_index;

    ### Strain 1 (required)
    if (defined $strain){
	if (exists $strains{$strain}){
	    $strain_index = $strains{$strain};
	    warn "Strain defined as '$strain' (strain index: $strain_index)\n";
	}
	else{
	    warn "Strain name specified [$strain] does not match any of the available strain names!\n";
	    warn "\nAvailable genomes to choose from are:\n";
	    warn "="x37,"\n";	
	    foreach my $strain(keys %strains){
		print "$strain\n";
	    }
	    warn "="x37,"\n";
	    die "\nPlease double check the name and try again (using '--strain NAME')\n\n";
	}
    }
    else{
	warn "No strain specified!\n";
	warn "\nAvailable genomes to choose from are:\n";
	warn "="x37,"\n";	
	foreach my $strain(keys %strains){
	    print "$strain\n";
	}
	warn "="x37,"\n";
	die "\nPlease choose one of the available strains using '--strain NAME' and try again\n\n";
    }
    
    ### Strain 2 (optional)
    if (defined $strain2){
	unless ($dual_hybrid){
	    warn "Strain 2 specified, setting option '--dual_hybrid'\n";
	    $dual_hybrid = 1;
	}
    }
    if ($dual_hybrid){
	warn "Dual Hybrid strain selected\n";
	if (defined $strain2){
	    if (exists $strains{$strain2}){
		$strain2_index = $strains{$strain2};
		warn "Strain2 defined as '$strain2' (strain2 index: $strain2_index)\n";
	    }
	    else{
		warn "Strain2 name specified [$strain2] does not match any of the available strain names!\n";
		warn "\nAvailable genomes to choose from are:\n";
		warn "="x37,"\n";	
		foreach my $strain(keys %strains){
		    print "$strain\n";
		}
		warn "="x37,"\n";
		die "\nPlease double check the name and try again (using '--strain2 NAME')\n\n";
	    }
	}
	else{
	    warn "No strain 2 specified!\n";
	    warn "\nAvailable genomes to choose from are:\n";
	    warn "="x37,"\n";	
	    foreach my $strain(keys %strains){
		print "$strain\n";
	    }
	    warn "="x37,"\n";
	    die "\nPlease choose one of the available strains using '--strain2 NAME' and try again\n\n";
	}
	
	# make sure that Strain 1 and Strain 2 are different from each other
	if ($strain eq $strain2){
	    die "Strain 1 [$strain] and Strain 2 [$strain2] must be different from each other. Please respecify!\n\n"; 
	}
    }

    ### GENOME FOLDER
    
    unless ($genome_folder){
	warn "Genome folder was not specified!\n";
	# print_helpfile();
	exit;
    }
    my $parent_dir = getcwd();    

    ### checking that the genome folder, all subfolders and the required bowtie index files exist
    unless ($genome_folder =~/\/$/){
	$genome_folder =~ s/$/\//;
    }
    
    if (chdir $genome_folder){
	my $absolute_genome_folder = getcwd; ## making the genome folder path absolute
	unless ($absolute_genome_folder =~/\/$/){
	    $absolute_genome_folder =~ s/$/\//;
	}
	warn "Reference genome folder provided is $genome_folder\t(absolute path is '$absolute_genome_folder)'\n\n";
	$genome_folder = $absolute_genome_folder;
    }
    else{
	die "Failed to move to genome folder > $genome_folder <: $!\n\nSNPsplit_genome_preparation --help for more details\n\n";
    }
    chdir $parent_dir or die "Failed to move back to parent directory $parent_dir\n\n";

    ### N-masking mode of action
    if ($no_nmasking){
	$nmasking = 0;
	$full_sequence = 1;
    }
    else{
	$nmasking = 1; # This is the default
    }

    return ($vcf_file,$strain,$strain2,$strain_index,$strain2_index,$genome_folder,$skip_filtering,$nmasking,$full_sequence,$dual_hybrid);

}


sub print_helpfile{
  print <<EOF

  SYNOPSIS:

SNPsplit is designed to read in alignment files in SAM/BAM format and determine the allelic origin of reads
that cover known SNP positions. For this to work the alignment step must have been carried out against a 
genome that had all SNP positions replaced by Ns, and a list of SNP positions between the two different genomes
has to be provided using the option --snp_file.

This module, SNPsplit_genome_preparation, allows you to specify a VCF file and generate a modified genome

  I) SNPsplit-tag: SNPsplit analyses reads (single-end mode) or read pairs (paired-end mode) for overlaps 
     with known SNP positions, and writes out a tagged BAM file in the same order as the original file.

 II) SNPsplit-sort: the tagged BAM file is read in and is being sorted into allele-specific files. This process
     may also be run as a stand-alone module (tag2sort).


The SNPsplit-tag module determines whether a read can be assigned to a certain allele and appends an additional
optional field 'XX:Z:' to each read. The tag can be one of the following:

                                        XX:Z:UA - Unassigned
                                        XX:Z:G1 - Genome 1-specific
                                        XX:Z:G2 - Genome 2-specific
                                        XX:Z:CF - Conflicting


The SNPsplit-sort module reads in the tagged BAM file and sorts the reads (or read pairs) according to their XX:Z:
tag (or the combination of tags for paired-end or Hi-C reads) into subfiles.


  USAGE:    SNPsplit_genome_preparation  [options] --vcf_file <file> --genome /path/to/genome/ --strain <strain_name>


--vcf_file <file>             Mandatory file specifying SNP information for mouse strains from the Mouse Genomes Project
                              (http://www.sanger.ac.uk/science/data/mouse-genomes-project). The file used and approved for
                              testing is called 'mgp.v5.merged.snps_all.dbSNP142.vcf.gz'. Please note that future versions
                              of this file or entirely different VCF files might not work out-of-be-box but may require some
                              tweaking. SNP calls are read from the VCF files, and high confidence SNPs are written into
                              a folder in the current working directory called SNPs_<strain_name>/chr<chromosome>.txt,
                              in the following format:

                                          SNP-ID     Chromosome  Position    Strand   Ref/SNP
                              example:   33941939        9       68878541       1       T/G


--strain <strain_name>        The strain you would like to use as SNP (ALT) genome. Mandatory. For an overview of strain names
                              just run SNPsplit_genome_preparation selecting '--list_strains'.

--list_strains                Displays a list of strain names present in the VCF file for use with '--strain <strain_name>'.

--dual_hybrid                 Optional. This will invoke a multi-step process:
                                 1) Read/filter SNPs for first strain (specified with '--strain <strain_name>')
                                 2) Write full SNP incorporated (and optionally N-masked) genome sequence for first strain
                                 3) Read/filter SNPs for second strain (specified with '--strain2 <strain_name>')
                                 4) Write full SNP incorporated (and optionally N-masked) genome sequence for second strain
                                 5) //TODO

                              The resulting genome will no longer relate to the original reference specified with '--reference_genome'.
                              Instead the new Reference (Ref) is defined by '--strain <strain_name>' and the new SNP genome
                              is defined by '--strain2 <strain_name>'.
                              

--strain2 <strain_name>       Optional. //TODO 

--reference_genome            The path to the reference genome, typically the strain 'Black6' (C57BL/6J), e.g.
                              '--reference_genome /bi/scratch/Genomes/Mouse/GRCm38/'. Expects one or more FastA files in this folder
                              (file extension: .fa or .fasta).

--skip_filtering              This option skips reading and filtering the VCF file. This assumes that a folder named
                              'SNPs_<Strain_Name>' exists in the working directory, and that text files with SNP information
                              are contained therein in the following format:

                                          SNP-ID     Chromosome  Position    Strand   Ref/SNP
                              example:   33941939        9       68878541       1       T/G

--nmasking                    Write out a genome version for the strain specified where Ref bases are replaced with 'N'. In the
                              Ref/SNP example T/G the N-masked genome would now carry an N instead of the T. The N-masked genome
                              is written to a folder called  '<strain_name>_N-masked/'. Default: ON.

--full_sequence               Write out a genome version for the strain specified where Ref bases are replaced with the SNP base.
                              In the Ref/SNP example T/G the full sequence genome would now carry a G instead of the T. The full
                              sequence genome is written out to folder called '<strain_name>_full_sequence/'. May be set in
                              addition to '--nmasking'. Default: OFF. 

--no_nmasking                 Disable N-masking if it is not desirable. Will automatically set '--full_sequence' instead.


--help                        Displays this help information and exits.

--version                     Displays version information and exits.


                                                             Last modified: 12 May 2016

EOF
    ;
  exit 1;
}

